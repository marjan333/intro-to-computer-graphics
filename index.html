<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js - pointerlock controls</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="css/main.css">

</head>

<body>
	<script src="js/three.js"></script>
	<script>
		"three.min.js"
	</script>
	<script src="js/PointerLockControls.js"></script>

	<script id="vertexShader" type="x-shader/x-vertex">
		varying vec3 vNormal;
void main()
{
    vNormal = normalize( normalMatrix * normal );
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>

	<!-- fragment shader a.k.a. pixel shader -->
	<script id="fragmentShader" type="x-shader/x-vertex">
		varying vec3 vNormal;
void main()
{
	float intensity = pow( 0.7 - dot( vNormal, vec3( 0.0, 0.0, 1.0 ) ), 4.0 );
    gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 ) * intensity;
}
</script>

	<div id="blocker">


		<div id="instructions" class="fade-out">
			<!-- (W, A, S, D = Move, MOUSE = Look around) -->
		</div>

	</div>

	<script>
		var camera, scene, renderer, controls;

		var Pos = new THREE.Vector3(0, 0, 0);
		var Dir = new THREE.Vector3(0, 0, 1);
		var ratio = window.innerWidth / window.innerHeight;


		var controlsEnabled = true;

		var moveForward = false;
		var moveBackward = false;
		var moveLeft = false;
		var moveRight = false;


		var stars = [];

		var prevTime = performance.now();
		var velocity = new THREE.Vector3();
		var direction = new THREE.Vector3();
		var color = new THREE.Color();



		const clock = new THREE.Clock();
		var speed = 1234;
		var angle = 0;


		function init() {

			camera = new THREE.PerspectiveCamera(45, ratio, 0.00001, 1000);
			camera.position.set(Pos.x, Pos.y, Pos.z);
			camera.lookAt(Dir.x, Dir.y, Dir.z);

			scene = new THREE.Scene();
			controls = new THREE.PointerLockControls(camera);
			controls.enabled = true;
			scene.add(controls.getObject());

			var onKeyDown = function(event) {

				switch (event.keyCode) {

					case 38: // up
					case 87: // w
						moveForward = true;
						break;

					case 37: // left
					case 65: // a
						moveLeft = true;
						break;

					case 40: // down
					case 83: // s
						moveBackward = true;
						break;

					case 39: // right
					case 68: // d
						moveRight = true;
						break;

				}

			};

			var onKeyUp = function(event) {

				switch (event.keyCode) {

					case 38: // up
					case 87: // w
						moveForward = false;
						break;

					case 37: // left
					case 65: // a
						moveLeft = false;
						break;

					case 40: // down
					case 83: // s
						moveBackward = false;
						break;

					case 39: // right
					case 68: // d
						moveRight = false;
						break;

				}
			};



			var geometry = new THREE.BoxGeometry(10000, 10000, 10000);
			var cubeMaterials = [
				new THREE.MeshBasicMaterial({
					map: new THREE.TextureLoader().load('images/sky_ft.png'),
					side: THREE.DoubleSide
				}),
				new THREE.MeshBasicMaterial({
					map: new THREE.TextureLoader().load('images/sky_bk.png'),
					side: THREE.DoubleSide
				}),
				new THREE.MeshBasicMaterial({
					map: new THREE.TextureLoader().load('images/sky_up.png'),
					side: THREE.DoubleSide
				}),
				new THREE.MeshBasicMaterial({
					map: new THREE.TextureLoader().load('images/sky_dn.png'),
					side: THREE.DoubleSide
				}),
				new THREE.MeshBasicMaterial({
					map: new THREE.TextureLoader().load('images/sky_rt.png'),
					side: THREE.DoubleSide
				}),
				new THREE.MeshBasicMaterial({
					map: new THREE.TextureLoader().load('images/sky_lf.png'),
					side: THREE.DoubleSide
				})

			];

			var material = new THREE.MeshFaceMaterial(cubeMaterials);
			var cube = new THREE.Mesh(geometry, material);
			scene.add(cube);

			var material_box = new THREE.MeshBasicMaterial();
			material_box.color = new THREE.Color(1, 0, 0);
			material_box.wireframe = true;
			var geometry_box = new THREE.BoxGeometry(100, 0.1, 100, 32, 1, 32);

			var BoxMesh = new THREE.Mesh(geometry_box, material_box);
			//BoxMesh.position.y=-0.1;
			scene.add(BoxMesh);



			document.addEventListener('keydown', onKeyDown, false);
			document.addEventListener('keyup', onKeyUp, false);

			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			window.addEventListener('resize', onWindowResize, false);
		}


		function animateStars() {
			// looping through each star
			for (var i = 0; i < stars.length; i++) {
				star = stars[i];

				// moving forward
				star.position.z += i / 10;

				//if a partical is too close move it to the back
				if (star.position.z > 1000) star.position.z -= 2000;
			}
		}

		function addSphere() {
			//adding random spherical particles
			//loop to go through z positions between -1000 to 1000, adding particles
			for (var z = -1000; z < 1000; z += 3) {

				//making a sphere
				var geometry = new THREE.SphereGeometry(0.5, 32, 32);
				var material = new THREE.MeshBasicMaterial({
					color: 0xffffff
				});

				var customMaterial = new THREE.ShaderMaterial({
					uniforms: {},
					vertexShader: document.getElementById('vertexShader').textContent,
					fragmentShader: document.getElementById('fragmentShader').textContent,
					side: THREE.BackSide,
					blending: THREE.AdditiveBlending,
					transparent: true
				});

				var sphere = new THREE.Mesh(geometry, customMaterial);

				//giving spheres random x and y positions between -500 and 500
				sphere.position.x = Math.random() * 1000 - 400;
				sphere.position.y = Math.random() * 1000 - 400;

				//setting the z position to where it is in the camera view.
				sphere.position.z = z;

				//scale it up
				sphere.scale.x = sphere.scale.y = 1.5;

				//add sphere to the scene
				scene.add(sphere);

				//pushing the sphere to the stars array
				stars.push(sphere);
			}

		}


		function render() {
			//get the frame
			requestAnimationFrame(render);
			//render the scene and animate the stars
			renderer.render(scene, camera);
			// animateStars();
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		var MyUpdateLoop = function() {
			var delta = clock.getDelta();
			if (moveLeft == true) {
				angle += speed * delta;
				Dir.x = Math.sin(angle);
				Dir.z = Math.cos(angle);
				Dir.normalize();
			}
			if (moveRight == true) {
				angle -= speed * delta;
				Dir.x = Math.sin(angle);
				Dir.z = Math.cos(angle);
				Dir.normalize();
			}
			if (moveForward == true) {
				Pos.x += Dir.x * speed;
				//Pos.y+=Dir.y*speed*delta;
				Pos.z += Dir.z * speed;
			}
			if (moveBackward == true) {
				Pos.x -= Dir.x * speed * delta;
				//Pos.y-=Dir.y*speed*delta;
				Pos.z -= Dir.z * speed * delta;
			}
			//recompute direction

			//call the render with the scene and the camera
			renderer.render(scene, camera);
			//finally perform a recoursive call to update again
			//this must be called because the mouse change the camera position
			//camera.rotation.x=0;
			//update the projection matrix given the new values
			//camera.updateProjectionMatrix();
			//
			// camera.position.set(Pos.x,Pos.y,Pos.z);
			// camera.lookAt(Pos.x+Dir.x,Pos.y+Dir.y,Pos.z+Dir.z);
			camera.updateProjectionMatrix();
			requestAnimationFrame(MyUpdateLoop);

		};

		requestAnimationFrame(MyUpdateLoop);

		function animate() {

			requestAnimationFrame(animate);

			if (controlsEnabled == true) {

				var time = performance.now();
				var delta = (time - prevTime) / 1000;

				velocity.x -= velocity.x * 10.0 * delta;
				velocity.z -= velocity.z * 10.0 * delta;

				direction.z = Number(moveForward) - Number(moveBackward);
				direction.x = Number(moveLeft) - Number(moveRight);
				direction.normalize();

				if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
				if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

				controls.getObject().translateX(velocity.x * delta);
				controls.getObject().translateZ(velocity.z * delta);

				prevTime = time;

			}
			renderer.render(scene, camera);
		}


		init();
		animate();
		addSphere();
		render();
	</script>
</body>

</html>
